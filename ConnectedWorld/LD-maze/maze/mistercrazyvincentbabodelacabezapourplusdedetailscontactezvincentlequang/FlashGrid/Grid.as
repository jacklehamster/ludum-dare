package {	/************************************	*	GRID ENGINE	*	*	© 24/11/2010 Vinh Le Quang	*	feel free to modify the code to fit your needs	*	**********************************/		////////////////////////////////////////////////////////////////////	//	//	In ActionScript, displayable objects are MovieClips, but the Grid	//	class uses "objects" to identify elements in the map.	//	//	The Map Object:	//	Every data that needs to be stored will be stored as a hierarchical structure in the	//	map object.	//	Map is split into cells accessible as map["x,y"]. Note that "x,y" is a string, it's not map[x,y].	//	Each map has then a floor, left/right wall and a hash of objects accessible by id (map["x,y"].objects[id]).	//	Elements in the map all contain all information necessary for the display, movement and interaction of the object.		import flash.display.Stage;	import flash.display.MovieClip;	import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.geom.Rectangle;	import flash.geom.Point;	import flash.events.Event;	import flash.events.IOErrorEvent;	import flash.events.MouseEvent;	import flash.display.Loader;	import flash.net.URLRequest;	import flash.net.URLVariables;	import flash.display.BitmapData;	import flash.display.Bitmap;	import flash.utils.getQualifiedClassName;	import flash.utils.getDefinitionByName;	import flash.utils.Dictionary;	import flash.events.EventDispatcher;	import flash.display.BlendMode;	import flash.system.ApplicationDomain;	import flash.display.LoaderInfo;	import flash.net.URLLoader;	import flash.display.FrameLabel;		public class Grid 		extends Sprite {		const DIRECTIONS = ['E','SE','S','SW','W','NW','N','NE'];		//	The entire world is stored here:		var map:Object = {};		var time:Number = 0;						var registry:Object = {};	//	Object access by id		var moveList:Array = [];	//	List of all moving objects		var thinkList:Array = [];	//	List of thinking objects				var pair:Dictionary = null;	//	Allow 1-on-1 relationship between objects and MovieClips		var mcCache:Object = {};	//	Contains all MovieClips		var idcount = 0;			//	For autogenerated IDs.		static var bitmapCache:Object = {};	//	All loaded images stored here		static var loadinprogress:Loader = null;	//	Current loader being used		static var fileinprogress:String = null;	//	current file being loaded		public var definitions:Object = {};		const YBLOCK = 20;		const XBLOCK = 50;		const THINKTIME = 10;				const arrivedevent = new Event("arrived");		const newdirectionevent = new Event("newdirection");				private var _background:String;		private var _backgroundShift:Point = new Point();						////////////////////////////////////////		// GRID CONSTRUCTOR		function Grid() {			pair = new Dictionary();			pair[null] = null;		}				////////////////////////////////////////		// grid2screen converts grid coordinates to screen coordinates, even if the object is not displayed on the screen		function grid2screen(xi:Number,yi:Number,shift:Object=null):Object {			return {x:xi*XBLOCK+yi*XBLOCK+(shift?-shift.x:0),y:-xi*YBLOCK+yi*YBLOCK+(shift?-shift.y:0)};		}				////////////////////////////////////////		// screen2grid converts screen coordinates to grid coordinates, even if the object is not displayed on the screen		public function screen2grid(xs:Number,ys:Number,shift:Object=null):Object {			if(shift) {				xs += shift.x;				ys += shift.y;			}			return {x:(xs/XBLOCK - ys/YBLOCK)/2,y:(xs/XBLOCK + ys/YBLOCK)/2};		}				////////////////////////////////////////		// zoom - zoom is a property. you can set grid.zoom=zoomvalue		public function set zoom(percent:int):void {			if(scaleX*100!=percent) {				scaleX = scaleY = percent/100;			}		}				public function get zoom():int {			return scaleX;		}				////////////////////////////////////////		// loop: Gets run continuously to update movements		var counter:int = 0;		var startime:int = 0;		function loop(e:Event) {			passTime();			counter++;			if(counter>100) {				var now = flash.utils.getTimer();				MovieClip(parent).fps.text = counter/(now-startime)*1000;				counter = 0;				startime = now;			}		}				private function distance(obj1:Object,obj2:Object):Number {			return Point.distance(toPoint(obj1.spot),toPoint(obj2.spot));		}				////////////////////////////////////////		// passTime: One game time moment has passed		function passTime() {			time++;			var i:int,obj:Object;						// iterate through all thinking objects 			for(i=time%THINKTIME;i<thinkList.length;i+=THINKTIME) {				obj = thinkList[i];				var thought = obj.thought;				delete obj.thought;				think(obj,thought);			}						// iterate through all moving objects (in reverse order cause the list might shrink)			for(i=moveList.length-1;i>=0;i--) {				obj = moveList[i];				var dx = obj.move.to.x-obj.spot.x;				var dy = obj.move.to.y-obj.spot.y;				var dist = Math.sqrt(dx*dx+dy*dy);				var speed = Math.min(dist, obj.follow && getById(obj.follow) && getById(obj.follow).speed ? getById(obj.follow).speed : .1, obj.speed ? obj.speed:.1);				if(obj.goal && obj.goal.range && distance(obj,obj.goal)<obj.goal.range) {					speed = 0;					delete obj.move.path;				}								var clip;				if(!speed && obj.move.path) {	//	if current move has been completed, continue with the saved path					var path = obj.move.path.shift();					if(!path) {						obj.move.path = null;					}					else {//	replace current move with the path						obj.move.to = path.to;						setMove(obj,path.to,false);						if(path.from) {							beam(obj,path.from);						}						dx = obj.move.to.x-obj.spot.x;						dy = obj.move.to.y-obj.spot.y;						dist = Math.sqrt(dx*dx+dy*dy);						speed = Math.min(dist,obj.speed?obj.speed:.1);					}				}				if(speed) {	//	move procedure. Calculate position and beam (teleport) there					var diffx = (dx/dist) * speed;					var diffy = (dy/dist) * speed;					if(!beam(obj,new Point(obj.spot.x+diffx,obj.spot.y+diffy),true)) {						obj.thought = {action:"move",to:obj.move.to};						still(obj);					}				}				else {	//	player has arrived. Stand still and notify with an 'arrived' event					still(obj);					if(obj.goal) {						var goal:Object = obj.goal;						delete obj.goal;						action(obj.id,goal.action,goal.subjectID,obj.spot,goal.details);						var cell:Object = find(obj.spot,"floor");						if(cell && cell.destination && !cell.startpoint) {							dispatchEvent(CustomEvent.create(CustomEvent.GOTO,cell.destination));						}					}				}			}		}				////////////////////////////////////////		// pathmove: make an object go to 'to' point using path finding		public function pathmove(obj:Object,to:Object):int {			still(obj);			var paths = pathFind(obj.spot,to);			if(paths) {				for(var p=1;p<paths.length;p++) {					stackmove(obj,null,paths[p]);				}				return paths.length-1;			}			return 0;		}		////////////////////////////////////////		// still: stop moving		public function still(obj) {			setMove(obj,null,true);			var clip:MovieClip = getClip(obj);			if(clip) {				clip.gotoAndStop(clip.currentLabel||clip.currentFrame);			}		}				public function canBeam(to:Object,type:String=null):Boolean {			var newix:int = Math.round(to.x);			var newiy:int = Math.round(to.y);			if(type) {				var cell = getCell(newix,newiy);				if(cell && cell[type])					return false;			}			else {				if(find(to,{block:1}))	//	the 'to' location is blocked by an object					return false;			}			return true;		}				////////////////////////////////////////		// canGo: can the character go from point 'from' to point 'to'?		function canGo(from:Object,to:Object):Boolean {			var newix:int = Math.round(to.x);			var newiy:int = Math.round(to.y);			if(!find(to,"floor"))				return false;	//	can't walk where there's no floor			if(find(to,{block:1}))	//	the 'to' location is blocked by an object				return false;			if(!from) {				return false;			}			var oldix:int = Math.round(from.x);			var oldiy:int = Math.round(from.y);			if(Math.abs(newix-oldix)>1 || Math.abs(newiy-oldiy)>1) {				return false;	// this function is only available for points that are 1 cell apart from each other			}			var wall = null;			if(Math.abs(newix-oldix)==1 && Math.abs(newiy-oldiy)==1) {	//	diagonal cells (moving N,S,E or W)				var pt1:Point = new Point(oldix,newiy);				var pt2:Point = new Point(newix,oldiy);				return canGo(from,pt1) && canGo(pt1,to) && canGo(from,pt2) && canGo(pt2,to);			}			if(newix-oldix==1) {	//	destination is a cell NE. Ensure it's not blocked by a wall				wall = find(from,"rwall");				return !wall || wall.door;			}			else if(newix-oldix==-1) {	//	destination is a cell SW. Ensure it's not blocked by a wall				wall = find(to,"rwall");				return !wall || wall.door;			}			if(newiy-oldiy==1) {	//	destination is a cell NW. Ensure it's not blocked by a wall				wall = find(to,"lwall");				return !wall || wall.door;			}			else if(newiy-oldiy==-1) {	//	destination is a cell SE. Ensure it's not blocked by a wall				wall = find(from,"lwall");				return !wall || wall.door;			}			return true;		}				////////////////////////////////////////		// roundPointComp: Compares positions pt1 and pt2 ensuring they both belong to the same cell		static function roundPointComp(pt1:Object,pt2:Object):Boolean {			return Math.round(pt1.x)==Math.round(pt2.x) && Math.round(pt1.y)==Math.round(pt2.y);		}				////////////////////////////////////////		// toPoint: transform {x:?,y:?} object to point		static public function toPoint(pt:Object):Point {			//	so, let's just go A=>C			return pt?new Point(pt.x,pt.y):null;		}				////////////////////////////////////////		// getHotSpot: get the hotspot of an object		static function getHotSpot(obj:Object,spot:Object=null):Point {			var hotspot:Object = obj.hotspot?obj.hotspot:{x:0,y:0};			if(!spot) {				spot = obj.spot;			}			return new Point(spot.x+hotspot.x,spot.y+hotspot.y);		}		////////////////////////////////////////		// cleanPath: Remove extra steps in the paths. For ex, path is A=>B=>C but A and B are within the same cell		function cleanPath(path:Array) {			//	so, let's just go A=>C			var i:int = 0;			while(i<path.length-2) {				var p:Point=toPoint(path[i]),p1:Point=toPoint(path[i+1]),p2:Point=toPoint(path[i+2]);				if(roundPointComp(p,p1) || p.subtract(p1).equals(p1.subtract(p2))) {					path.splice(i+1,1);				}				else {					i++;				}			}		}				////////////////////////////////////////		// pathFind: Use breath first search to find the fastest path from 'from' to 'to'		public function pathFind(from:Object,to:Object):Array {			var dest:Point = new Point(Math.round(to.x),Math.round(to.y));			var org:Point = new Point(Math.round(from.x),Math.round(from.y));			var stack:Array = [{p:org,d:0}];			var visited:Object = {};			visited[org] = org.equals(new Point(from.x,from.y))?null:from;			var closest:Point = null;			var mindist:Number = 0;			var surround:Array = [new Point(-1,0),new Point(1,0),new Point(0,-1),new Point(0,1),						 new Point(-1,-1),new Point(1,1),new Point(1,-1),new Point(-1,1)];	// all cells around			var success:Boolean = false;			while(stack.length) {				var info = stack.shift();				var here:Point = info.p;				var dist:Number = Point.distance(dest,here);				if(!closest || dist<mindist) {	//	the closest point found during pathfind will be saved					closest = here;					mindist = dist;				}				if(canGo(here,dest)) {					closest = here;					success = true;					break;				}				if(info.d<15) {	//	maximum depth of breath first search: 15					for(var i=0;i<surround.length;i++) {						var pt:Point = here.add(surround[i]);	// if the point is accessible and not yet visited,						if(!visited.hasOwnProperty(pt) && canGo(here,pt)) {	//	add it to the search list							visited[pt] = here;	//	and use the visited hash to store where the search probe came from							stack.push({p:pt,d:info.d+1});						}					}				}			}			var p:Object = closest;			var path:Array = [];			while(p) {				path.push(p);				p = visited[p];			}			if(success)				path.unshift(to);			path = path.reverse();			cleanPath(path);			return path;		}				////////////////////////////////////////		// stackmove: Add a movement to be performed at the end of the path list		public function stackmove(obj:Object,from:Object,to:Object) {			if(!obj.move) {				if(from) {					beam(obj,from);				}				setMove(obj,to,false);			}			else {				if(!obj.move.path) {					obj.move.path = [];				}				var path = {to:to};				if(from) {					path.from = from;				}				obj.move.path.push(path);			}		}		////////////////////////////////////////		// insertmove: Perform a move now, then return to the path list		public function insertmove(obj:Object,from:Object,to:Object) {			if(!obj.move) {				if(from) {					beam(obj,from);				}				setMove(obj,to,false);			}			else {				if(!obj.move.path) {					obj.move.path = [];				}				var path = {to:obj.move.to};				if(from) {					beam(obj,from);				}				obj.move.path.push(path);				obj.move.to = {x:to.x,y:to.y};			}		}				////////////////////////////////////////		// setMove: Helper function for setting the movement		function setMove(obj:Object,to:Object,reset:Boolean,moonwalk:Boolean=false) {			if(to) {				var oldpath = !reset&&obj.move?obj.move.path:null;				var olddirection = obj.move?obj.direction:null;				obj.move = {to:{x:to.x,y:to.y}};				delete obj.sitting;				if(oldpath) {					obj.move.path = oldpath;				}				//	check the new direction and notify through an event				var screendiff = (toPoint(grid2screen(to.x,to.y)).subtract(toPoint(grid2screen(obj.spot.x,obj.spot.y))));				var newdirection = (Math.round(180*(Math.atan2(screendiff.y,screendiff.x)/Math.PI) + (moonwalk?180:0))+360)%360;				if(newdirection!=olddirection) {					switch(DIRECTIONS[newdirection]) {						case "E":						case "NE":						case "SE":							obj.orientation = "E";							break;						case "W":						case "NW":						case "SW":							obj.orientation = "W";							break;					}															obj.direction = newdirection;					var clip = getClip(obj);					if(clip) {						clip.play();						//clip.dispatchEvent(newdirectionevent);					}				}			}			else {	//	if to is null, stop				if(obj.move) {					delete obj.move;				}			}			enlistMove(obj);		}										////////////////////////////////////////		// resetmove: move and clear the path list		function resetmove(obj:Object,from:Object,to:Object,moonwalk:Boolean=false) {			if(from) {				beam(obj,from);			}			setMove(obj,to,true,moonwalk);		}				////////////////////////////////////////		// getCell: Get the cell at position x,y. create flag to create if it doesn't exists		public function getCell(x:int,y:int,create:Boolean=false) {			var pos = [x,y].join(",");			if(!map[pos] && create) {	//	cells have slots for 1 floor, 2 walls and a stack of objects				map[pos] = {  };			}			return map[pos];		}		////////////////////////////////////////		// getClip: Get the MovieClip from an object		public function getClip(obj:Object,create:Boolean=false):MovieClip {			if(!pair[obj] && create) {				pair[obj] = createClip(obj);			}			return pair[obj];		}		////////////////////////////////////////		// getObj: Get an object from a MovieClip		public function getObj(mc:MovieClip):Object {			return pair[mc];		}				////////////////////////////////////////		// isVisible: Check if an object is on screen		public function isVisible(obj:Object):Boolean {			var clip:MovieClip = getClip(obj);			return clip && clip.parent;		}				////////////////////////////////////////		// find: Look at cell at position point, using the search information.		//	pass search = "lwall" / "rwall" / "floor" to return the corresponding wall or floor of this cell		//	pass search = {id:x} to get object with id x in that cell		//	pass search = {prop:x} and it will find the first object with property prop=x		//	pass search = {prop:null} and it will find the first object with property prop of any value		public function find(point:Object,search:Object=null):Object {			if(!point)				return null;			var ix = Math.round(point.x);			var iy = Math.round(point.y);			var cell = getCell(ix,iy);			if(cell) {				if(search is String) {					return cell[search];				}				if(!cell.objects) {					return null;				}				if(search) {					if(search.id && cell.objects[search.id]) {						return cell.objects[search.id];					}				}				for(var id in cell.objects) {					var obj = cell.objects[id];					if(!search)						return obj;					else {						for(var i in search) {							if(obj.hasOwnProperty(i) && (obj[i]==search[i] || !search[i])) {								return obj;							}						}					}				}			}			return null;		}		////////////////////////////////////////		// unregister: deletes an object from existence		public function unregister(object:Object) {			var clip:MovieClip = getClip(object);			retrieve(object);			if(registry[object.id]) {				if(clip) {					if(clip.oldID)						delete mcCache[clip.oldID];					delete mcCache[clip.id];					delete pair[object];					delete pair[clip];				}				delete registry[object.id];				if(thinkList.indexOf(object)>=0) {					thinkList.splice(thinkList.indexOf(object),1);				}			}		}		////////////////////////////////////////		// retrieve: deletes an object from its cell		public function retrieve(object:Object):Object {			if(object.spot) {				var ix = Math.round(object.spot.x);				var iy = Math.round(object.spot.y);				var dimension:Array = object.dimension?object.dimension.split("x"):[1,1];				for(var xx=0;xx<dimension[0];xx++) {					for(var yy=0;yy<dimension[1];yy++) {						var cell = getCell(ix+xx,iy+yy);						if(cell) {							if(cell.objects && cell.objects[object.id]) {								delete cell.objects[object.id];								var hassomething = false;								for(var i in cell.objects) {									hassomething=true;									break;								}								if(!hassomething) {									delete cell.objects;								}							}							else if(object.type && cell[object.type]==object) {								delete cell[object.type];							}														for(i in cell) {								hassomething = true;								break;							}							if(!hassomething) {								delete map[[ix+xx,iy+yy].join(",")];							}						}					}				}			}			return object;		}						////////////////////////////////////////		// createID: Every object needs a unique id. We'll provide one if you forgot to do it		function createID():String {			var id:String;			do {				id = "xid_"+idcount++;			} while(registry[id]);			return id;		}				////////////////////////////////////////		// add: Add an object into the grid at point x,y		//	object format:		//		type:"floor/lwall/rwall" adds floor or walls		//		image:"image" image used for skinning. Only available for floor and walls		//		className:"class" MovieClip class used to display. Only available for objects		//		dimension:"?x?" Space that the object occupies		//		id: Only for objects. ID of the object		//		block:1 Object blocks passage		//		speed:? speed of the object when moving		//	objects can have more properties if needed outside the engine		public function add(point:Object,object:Object):Object {			var ix = Math.round(point.x);			var iy = Math.round(point.y);			var dimension:Array = object.dimension?object.dimension.split("x"):[1,1];			object.spot = {x:object.snap?ix:point.x,y:object.snap?iy:point.y};			if(!object.id) {				object.id =createID();			}			register(object);			for(var xx=0;xx<dimension[0];xx++) {				for(var yy=0;yy<dimension[1];yy++) {					var cell = getCell(ix+xx,iy+yy,true);					if(object.type)	{ //	floor/lwall/rwall						if(cell[object.type]) {							retrieve(cell[object.type]);						}						cell[object.type] = object;					}					else {	//	object						if(!cell.objects)							cell.objects = new Object();						cell.objects[object.id] = object;					}				}			}			return object;		}				////////////////////////////////////////		// fadeIn: fade in an image		static public function fadeIn(mc:DisplayObject,targetalpha:Number=1) {			var count =0;			mc.alpha = 0;			mc.addEventListener(Event.ENTER_FRAME,				function(e) {					mc.alpha = (count+=10)/100 * targetalpha;					if(count>=100) {						e.currentTarget.removeEventListener(e.type,arguments.callee);					}				});		}		////////////////////////////////////////		// popIn: popIn in an image		static public function popIn(mc:DisplayObject) {			var count =0;			var sx = mc.scaleX<0?-1:1;			var sy = mc.scaleY<0?-1:1;			mc.scaleX = .1*sx;			mc.scaleY = .1*sy;			mc.addEventListener(Event.ENTER_FRAME,				function(e) {					mc.scaleX = sx*(count+=25)/100;					mc.scaleY = sy*(count+=25)/100;					if(count>=100) {						e.currentTarget.removeEventListener(e.type,arguments.callee);					}				});		}		////////////////////////////////////////		// skin: Load an external image to replace the current image		//	This function is currently implemented for floor and walls only, but we could easily include objects too		function skin(element:MovieClip,image:String,xp:Number,yp:Number):Boolean {			if(element.skin == image) {				return true;			}			if(!image) {				bmp = element.getChildByName("skin") as Bitmap;				if(bmp)					element.removeChild(bmp);				delete element.skin;				return true;			}			if(bitmapCache.hasOwnProperty(image)) {	//	place the bitmap if it's been cached				var bmpd:BitmapData = bitmapCache[image];				if(bmpd) {					var bmp:Bitmap = new Bitmap(bitmapCache[image],"auto",true);					bmp.name = "skin";					bmp.scaleX = bmp.scaleY = element.scale?element.scale:1;					bmp.x = xp*bmp.width;					bmp.y = yp*bmp.height;					while(element.numChildren) {						element.removeChildAt(0);					}					element.addChild(bmp);					element.skin = image;					fadeIn(bmp,element.ghost?.5:1);					return true;				}				else					return false;			}			if(!element.doSkin) {				element.doSkin = function(e) {					skin(element,image,xp,yp);				}			}			if(loadinprogress && fileinprogress!=image) {	//	if a different file is being loaded, delay the skinning				loadinprogress.contentLoaderInfo.removeEventListener(Event.COMPLETE,element.doSkin);				loadinprogress.contentLoaderInfo.removeEventListener(IOErrorEvent.IO_ERROR,element.doSkin);				loadinprogress.contentLoaderInfo.addEventListener(Event.COMPLETE,element.doSkin);				loadinprogress.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR,element.doSkin);				return false;			}			var loader:Loader = loadinprogress;	// load bitmap from an external source			var request:URLRequest = null;			if(!loader){				fileinprogress = image;				loader = loadinprogress = new Loader();				//	url: I needed the php hack below because agilityhoster.com won't let me access images directly				//var url = image;//"http://davinci.agilityhoster.com/wonda/img.php?file="+image;				var urlsplit:Array = loaderInfo.url.split('/');				urlsplit[urlsplit.length-1]=image;				var url = urlsplit.join("/");				//trace(loaderInfo.url,url);				//url += "&id="+element.id;				request = new URLRequest(url);				//request.data = new URLVariables();				//request.data.res = element.id;				//trace(request.url);				loader.contentLoaderInfo.addEventListener(Event.COMPLETE,					function(e) {	//	once image is loaded, save it in the cache						bitmapCache[image] = e.currentTarget.content.bitmapData;						loader.unloadAndStop();						loadinprogress = null;					});				loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR,					function(e) {						bitmapCache[image] = null;						loader.unloadAndStop();						loadinprogress = null;					});							}			//	once image is loaded, skin the object			loader.contentLoaderInfo.addEventListener(Event.COMPLETE,element.doSkin);						if(request) {				loader.load(request);			}			return false;		}				////////////////////////////////////////		// beam: Teleport obj to position point, optionally check for collision		public function beam(obj:Object,point:Object,collision:Boolean=false,type:String=null):Boolean {			var oldix:int = obj.spot?Math.round(obj.spot.x):0;			var oldiy:int = obj.spot?Math.round(obj.spot.y):0;			var newix:int = Math.round(point.x);			var newiy:int = Math.round(point.y);			if(!obj.spot||oldix!=newix||oldiy!=newiy) {	// different ccell				if(collision) {					var ipt = obj.spot?Point.interpolate(toPoint(obj.spot),toPoint(point),-.9):point;					if(!canBeam(ipt,obj.type) || !canGo(obj.spot,ipt)) {						return false;					}				}				var oldCell:Object = find(obj.spot,"floor");				var newCell:Object = find(point,"floor");				dispatchEvent(CustomEvent.create(CustomEvent.CELLCHANGE,					{oldCell:oldCell,newCell:newCell,character:obj}));								var o = retrieve(obj);				if(type)					o.type = type;				add(point,o);			}			else {	// same cell				obj.spot = {x:point.x,y:point.y};			}			return true;		}				////////////////////////////////////////		// compareDisplay: Compare two movieclips for z-ordering (figure out which one shows on top)		static public function compareDisplay(mc1:MovieClip,mc2:MovieClip):int {			return mc1.layer!=mc2.layer?mc2.layer-mc1.layer:mc1.zcell!=mc2.zcell?mc2.zcell-mc1.zcell:mc1.y!=mc2.y?mc1.y-mc2.y:mc1.x-mc2.x;		}				////////////////////////////////////////		// display: Choose where and how to place MovieClips		//	pass shift as the screen offset to place the camera		//	pass screen as the dimension of the grid to display		//	pass fillfloor=true if you want to show the default floor display		public function display(shift:Point,screen:Rectangle,fillfloor:Boolean,invisCell:Number,showOutOfBound:Boolean=false) {			var topleft = screen2grid(screen.x+shift.x,screen.y+shift.y);			var botright = screen2grid(screen.x+shift.x+screen.width,screen.y+shift.y+screen.height);			var topright = screen2grid(screen.x+shift.x+screen.width,screen.y+shift.y);			var botleft = screen2grid(screen.x+shift.x,screen.y+shift.y+screen.height);			var minpoint = new Point(				Math.min(topleft.x,topright.x,botleft.x,botright.x),				Math.min(topleft.y,topright.y,botleft.y,botright.y));			var maxpoint = new Point(				Math.max(topleft.x,topright.x,botleft.x,botright.x),				Math.max(topleft.y,topright.y,botleft.y,botright.y));			//	loop through all displayable cell			var displays:Array = [];						var posList:Object = {}, pos:String, spot:Object, xi:int, yi:int, split:Array;			for(pos in map) {				split = pos.split(",");				xi = split[0];				yi = split[1];				spot = grid2screen(xi,yi,shift);				if(showOutOfBound || spot.x>=screen.x-XBLOCK && spot.y>=screen.y-YBLOCK && spot.x<=screen.x+screen.width+XBLOCK && spot.y<=screen.y+screen.height+YBLOCK) {					posList[pos] = {spot:spot,xi:xi,yi:yi};				}			}						if(fillfloor) {				for(yi=Math.floor(minpoint.y);yi<Math.ceil(maxpoint.y);yi++) {					for(xi=Math.floor(minpoint.x);xi<Math.ceil(maxpoint.x);xi++) {						pos = [xi,yi].join(",");						spot = grid2screen(xi,yi,shift);						if(showOutOfBound || spot.x>=screen.x-XBLOCK && spot.y>=screen.y-YBLOCK && spot.x<=screen.x+screen.width+XBLOCK && spot.y<=screen.y+screen.height+YBLOCK) {							if(!map[pos]) {								posList[pos] = {spot:spot,xi:xi,yi:yi};							}						}					}				}			}						for(pos in posList) {				var posInfo:Object = posList[pos];				xi = posInfo.xi;				yi = posInfo.yi;				spot = posInfo.spot;								//	clean cell				getCell(xi,yi);								//	display the floor (				var element = null;				var id:String = "floor_"+pos;								element = !fillfloor&&(!map[pos]||!map[pos].floor)?null:mcCache[id];				if(!element && (fillfloor||map[pos]&&map[pos].floor)) {					element = new Box();	//	create a floor					element.id = id;					mcCache[id] = element;					element.type = "floor";					element.cacheAsBitmap = true;					element.info.text = pos;					element.info.mouseEnabled = false;				}				if(element) {					element.x = spot.x;	//	place the floor					element.y = spot.y-YBLOCK;					element.zcell = (xi-yi);					element.layer = 1;					if(displays.indexOf(element)<0) {						displays.push(element);						addChild(element);					}				}				//	display the walls				if(map[pos]) {					var place = null;					if(map[pos].floor) {						element = createClip(map[pos].floor,element);						if(element) {							if(!pair[element]) {								pair[element] = map[pos].floor;								pair[map[pos].floor] = element;							}							place = grid2screen(									map[pos].floor.spot.x,									map[pos].floor.spot.y,									shift);							element.x = place.x;							element.y = place.y-YBLOCK;							element.zcell = (xi-yi);							element.visible = !map[pos].floor.hidden && invisCell!=1;							element.alpha = invisCell?invisCell:1;							element.layer = 1;							if(map[pos].floor.image)								skin(element,map[pos].floor.image,-.5,0);						}					}					if(map[pos].lwall) {						element = mcCache[map[pos].lwall.id];						element = createClip(map[pos].lwall,element);						if(element) {							if(map[pos].lwall.image)								skin(element,map[pos].lwall.image,0,-1);							place = grid2screen(									map[pos].lwall.spot.x,									map[pos].lwall.spot.y,									shift);							element.x = place.x-XBLOCK;							element.y = place.y;							element.zcell = (xi-yi)+1;							element.visible = !map[pos].lwall.hidden && invisCell!=1;							element.alpha = invisCell?invisCell:1;							element.scaleX = 1;							element.layer = 1;							if(displays.indexOf(element)<0) {								displays.push(element);								addChild(element);							}							if(!pair[element]) {								pair[element] = map[pos].lwall;								pair[map[pos].lwall] = element;							}						}					}					if(map[pos].rwall) {						element = mcCache[map[pos].rwall.id];						element = createClip(map[pos].rwall,element);						if(element) {							if(map[pos].rwall.image)								skin(element,map[pos].rwall.image,0,-1);							place = grid2screen(									map[pos].rwall.spot.x,									map[pos].rwall.spot.y,									shift);							element.x = place.x+XBLOCK;							element.y = place.y;							element.zcell = (xi-yi)+1;							element.visible = !map[pos].rwall.hidden && invisCell!=1;							element.alpha = invisCell?invisCell:1;							element.scaleX = -1;							element.layer = 1;							if(displays.indexOf(element)<0) {								displays.push(element);								addChild(element);							}							if(!pair[element]) {								pair[element] = map[pos].rwall;								pair[map[pos].rwall] = element;							}						}					}					//	display objects					if(map[pos].objects) {						for(var o in map[pos].objects) {							var obj:Object = map[pos].objects[o];							element = mcCache[o];							element = createClip(obj,element);							if(element) {								if(obj.image)									skin(element,obj.image,-.5,-.5);								var objspot:Object = obj.anchor && registry[obj.anchor]?registry[obj.anchor].spot:obj.spot;								place = grid2screen(									objspot.x,									objspot.y,									shift);								element.x = place.x;								element.y = place.y;								element.scaleX = element.scaleY = 1;								element.zcell = xi-yi;								element.visible = !obj.hidden;								element.layer = obj.topMost?0:1;								if(obj.rotation) {									element.rotation = obj.rotation;								}								if(obj.frame) {									element.gotoAndStop(obj.frame);								}								else									setLabel(obj,element);																if(displays.indexOf(element)<0) {									displays.push(element);									addChild(element);								}								if(!pair[element]) {									pair[element] = obj;									pair[obj] = element;								}							}						}					}				}			}						//	sort display and remove extras			displays.sort(compareDisplay);			var exists:Object = {};			for(var i=0;i<displays.length;i++) {				setChildIndex(displays[i],i);				exists[displays[i].name] = true;			}						if(background) {				var loader:Loader = getChildByName("background") as Loader;				if(loader) {					exists["background"] = true;					loader.x = -shift.x + backgroundShift.x;					loader.y = -shift.y + backgroundShift.y;					setChildIndex(loader,0);				}			}						for(i=numChildren-1;i>=0;i--) {				var child = getChildAt(i);				if(!exists[child.name]) {					removeChild(child);				}			}		}		public function setLabel(obj:Object,element:MovieClip):void {			var label:String= obj.hasOwnProperty("direction")?DIRECTIONS[(Math.round(8*(obj.direction+360)/360)+8)%8]:null;			if(!label)				label = 'S';			if(obj.sitting) {				//	direction+SIT / SIT				label = element.maplabel[label+"Sit"] ||						element.maplabel[obj.orientation+"Sit"] ||						element.maplabel["Sit"] ||						element.maplabel["any"];			}			//		const DIRECTIONS = ['E','SE','S','SW','W','NW','N','NE'];			if(!element.maplabel[label]) {				switch(label) {					case "E":						label = element.maplabel["SE"] || element.maplabel["NE"] || element.maplabel["S"] || element.maplabel["any"];						break;					case "W":						label = element.maplabel["SW"] || element.maplabel["NW"] || element.maplabel["S"] || element.maplabel["any"];						break;					case "SE":						label = element.maplabel["S"] || element.maplabel["E"] || element.maplabel["any"];						break;					case "SW":						label = element.maplabel["S"] || element.maplabel["W"] || element.maplabel["any"];						break;					case "NE":						label = element.maplabel["N"] || element.maplabel["E"] || element.maplabel["SE"] || element.maplabel["S"] || element.maplabel["any"];						break;					case "NW":						label = element.maplabel["N"] || element.maplabel["W"] || element.maplabel["SW"] || element.maplabel["S"] || element.maplabel["any"];						break;					case "N":						label = element.maplabel["N"+obj.orientation] || element.maplabel[obj.orientation] || element.maplabel["S"+obj.orientation] || element.maplabel["any"];						break;					case "S":						label = element.maplabel["S"+obj.orientation] || element.maplabel[obj.orientation] || element.maplabel["N"+obj.orientation] || element.maplabel["any"];						break;				}			}			if(element.currentLabel!=label)				if(obj.move)					element.gotoAndPlay(label);				else					element.gotoAndStop(label);		}				public function set backgroundShift(point:Object):void {			_backgroundShift = toPoint(point);		}				public function get backgroundShift():Object {			return _backgroundShift;		}				public function set background(value:String):void {			if(_background != value) {				_background = value;				var loader:Loader = getChildByName("background") as Loader;				if(loader) {					loader.unloadAndStop();					removeChild(loader);				}				if(value) {					loader = loadSwf(value,true,false);					loader.contentLoaderInfo.addEventListener(Event.COMPLETE,						function(e:Event):void {							e.currentTarget.removeEventListener(e.type,arguments.callee);							for(var i:int=0;i<(loader.content as MovieClip).numChildren;i++) {								var child:Sprite = (loader.content as MovieClip).getChildAt(i) as Sprite;								if(!child)									continue;								if(child.getChildByName("tothesky")) {									var obj:Object = getById(child.name);									if(!obj) {										obj = add(new Point(),{id:child.name,className:getQualifiedClassName(child),file:value,guided:1});									}									child.visible = false;									guideObject(obj.id,child);								}							}						});					loader.name = "background";					addChildAt(loader,0);				}			}		}				private function guideObject(id:String,guide:Sprite):void {			guide.addEventListener(Event.ENTER_FRAME,				function(e:Event):void {					var obj:Object = getById(id);					if(obj) {						beam(obj,screen2grid(guide.x+backgroundShift.x,guide.y+backgroundShift.y),false);						obj.rotation = guide.rotation;						if(guide is MovieClip) {							obj.frame = (guide as MovieClip).currentFrame;						}					}				});		}				public function get background():String {			return _background;					}				function getClassDefinition(className:String,obj:Object):Class {			var Definition:Class = definitions[className]?definitions[className].definition:null;			if(!Definition && !definitions.hasOwnProperty(className)) {				if(loaderInfo.applicationDomain.hasDefinition(className)) {					Definition = getDefinitionByName(className) as Class;					definitions[className] = {hotspot:obj.hotspot,definition:Definition,object:obj.object};				}				if(obj.file) {					if(loadSwf(obj.file,false,true)) {						definitions[className] = null;					}				}			}			if(definitions[className] && definitions[className].empty) {				definitions[className].hostpot = obj.hotspot;				definitions[className].object = obj.object;				delete definitions[className].empty;			}			return Definition;		}				public function loadSwf(filename:String,force:Boolean,unloadOnComplete:Boolean):Loader {			var loader:Loader = null;			var request:URLRequest = null;			if(!loadinprogress || force){				loader = new Loader();				if(!loadinprogress) {					loadinprogress = loader;					fileinprogress = filename;				}				//	url: I needed the php hack below because agilityhoster.com won't let me access images directly				//var url = image;//"http://davinci.agilityhoster.com/wonda/img.php?file="+image;				var urlsplit:Array = loaderInfo.url.split('/');				urlsplit[urlsplit.length-1]=filename;				var url = urlsplit.join("/");				//trace(loaderInfo.url,url);				//url += "&id="+element.id;				request = new URLRequest(url);				//request.data = new URLVariables();				//request.data.res = element.id;				//trace(request.url);				loader.contentLoaderInfo.addEventListener(Event.COMPLETE,					function(e) {							var loaderInfo:LoaderInfo = e.currentTarget as LoaderInfo;						var applicationDomain:ApplicationDomain = loaderInfo.applicationDomain;						checkDefinitions(applicationDomain,filename);						if(unloadOnComplete) {							loader.unloadAndStop();						}						if(loadinprogress == loader) {							loadinprogress = null;						}					});				loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR,					function(e) {						loader.unloadAndStop();						if(loadinprogress == loader) {							loadinprogress = null;						}					});								if(request) {					loader.load(request);				}			}			return loader;		}				public function checkDefinitions(applicationDomain:ApplicationDomain,filename:String):void {			var vector:Vector.<String> = applicationDomain.getQualifiedDefinitionNames();			for each(var def:String in vector) {				definitions[def] = {object:def,empty:true,definition:applicationDomain.getDefinition(def),file:filename};			}		}		////////////////////////////////////////		// createClip: Creates a movieclip corresponding to an object		function createClip(obj:Object,element:MovieClip=null):MovieClip {			if(!element) {				var Definition:Class = obj.className ? getClassDefinition(obj.className,obj):							obj.type=="lwall"||obj.type=="rwall"?Wall:							obj.type=="floor"||obj.image?Box:							null;				element = Definition ? new Definition():null;				if(!element)					return null;			}			if(!element.initialized) {				if(element.id) {					element.oldID = element.id;				}				element.id = obj.id;				mcCache[obj.id] = element;				element.initialized = true;								element.maplabel = {};				for(var i:int=0;i<element.currentLabels.length;i++) {					var label:FrameLabel = element.currentLabels[i] as FrameLabel;					element.maplabel[label.name] = label.name;					element.maplabel["any"] = label.name;				}				dispatchEvent(CustomEvent.create("clipcreated",{clip:element,object:obj,id:obj.id}));			}			element.scale = obj.scale;			element.ghost = obj.ghost;			element.type = obj.type;			element.cacheAsBitmap = obj.type!=null;			return element;		}		////////////////////////////////////////		// action: A character performs an action		public function action(characterID:String,activity:String,subjectID:String=null,spot:Object=null,details:Object=null):Boolean {			var character = registry[characterID];			var subject = registry[subjectID];			trace("*",characterID,activity,subjectID);						var canAct:Boolean = true;			if(spot || subject && subject.spot) {				if(character.range && character.range[activity] ||					activity=="combo" && character.itemlock && registry[character.itemlock].range) {					var range = character.range?character.range[activity]:registry[character.itemlock].range;					var dist:Number = Point.distance(toPoint(character.spot),toPoint(spot?spot:subject.spot));					canAct = dist<=range;				}				else if(spot) {					canAct = subject && subject.id==character.itemlock ? roundPointComp(spot,character.spot) : subject && subject.range? Point.distance(toPoint(character.spot),getHotSpot(subject,subject.spot)) <= subject.range : subject ? roundPointComp(subject.spot,character.spot) : roundPointComp(spot,character.spot);				}				else {					var found = find(character.spot,subject.type?subject.type:{id:subject.id});					canAct = found!=null;				}			}							if(!canAct) {				if(!details || !details.retry) {					resetmove(character,null,subject?getHotSpot(subject,toPoint(spot)):spot);					character.goal = subject?{action:activity,subjectID:subjectID,spot:getHotSpot(subject,toPoint(spot))}:{action:activity,spot:spot};					character.goal.details = details || {retry:0};					character.goal.details.retry ++;					if(subject && subject.range)						character.goal.range = subject.range;				}				else {					//	activity cancelled					if(character.itemlock)						character.itemlock = null;				}			}			if(canAct) {				return act(character,activity,subject);			}			return false;		}				////////////////////////////////////////		// enlistMove: Ensures an object is added to the appropriate move list		function enlistMove(obj):Boolean {			var index = moveList.indexOf(obj);			if(obj.move) {				if(index<0) {					moveList.push(obj);					return true;				}			}			else {				if(index>=0) {					moveList[index] = moveList[moveList.length-1];					moveList.pop();					return true;				}			}			return false;		}		////////////////////////////////////////		// enlistThink: Ensures an object is added to the appropriate think list		function enlistThink(obj):Boolean {			var index = thinkList.indexOf(obj);			if(obj.character || obj.speech || obj.follow) {				if(index<0) {					thinkList.push(obj);					return true;				}			}			else {				if(index>=0) {					thinkList[index] = thinkList[moveList.length-1];					thinkList.pop();					return true;				}			}			return false;		}		////////////////////////////////////////		// populateLists: Updates registry, moveList and thinkList. (Calls needed post load)		function populateLists():void {			var changed:Boolean = false;			for(var pos in map) {				var cell:Object = map[pos];				for(var type in cell) {					if(type=="objects") {						for(var o in cell.objects) {							if(register(cell.objects[o])) {								changed = true;							}						}					}					else {						if(register(cell[type])) {							changed = true;						}					}				}			}		}		////////////////////////////////////////		// register: Ensures objects are registered		function register(object:Object):Boolean {			if(!registry[object.id]) {				registry[object.id] = object;				enlistMove(object);				enlistThink(object);				return true;			}			return false;		}		////////////////////////////////////////		// getById: Get an object by ID		public function getById(id:String):Object {			return registry[id];		}		////////////////////////////////////////		// act: a character performs an action [can be overriden]		protected function act(character:Object,action:Object,subject:Object):Boolean {			switch(action) {				default:					dispatchEvent(CustomEvent.create(CustomEvent.INTERACT,{character:character,action:action,subject:subject}));			}			return true;		}				public function removeObjects(filter:Object=null,exception:Object=null):void {			for(var pos:String in map) {				var array:Array = pos.split(",");				var obj:Object;				do {					obj = find({x:array[0],y:array[1]},filter);					if(obj==exception)						obj = null;					if(obj)						unregister(obj);				} while(obj);			}		}				////////////////////////////////////////		// think: the character think [can be overriden]		//	This function is run periodically. Each character		//	is given some time to think. Use this function with		//	moderation to perform complex operations such as		//	path finding.		protected function think(character:Object,thought:Object):Boolean {			var handled:Boolean = false;			if(thought) {				switch(thought.action) {					case "move":						handled = 1<pathmove(character,thought.to);						break;					default:						dispatchEvent(CustomEvent.create("think",{thought:thought}));				}			}			if(!handled) {				if(character.speech) {					var msg = registry[character.speech];					if(msg) {						if(!msg.expire) {							msg.expire = time + msg.msg.length*5 + 15;						}						else if(msg.expire<time) {							unregister(msg);							delete character.speech;							enlistThink(character);						}					}				}				if(character.follow && !character.goal) {					var subject = registry[character.follow];					if(subject) {						var hotspot:Point = getHotSpot(subject);						var dist:Number = Point.distance(toPoint(character.spot),hotspot);						var followdistance:Number = character.followdistance?character.followdistance:1;						var maxdist:Number = followdistance+.5;						var mindist:Number = followdistance-.5;						if(maxdist<dist || mindist>dist) {							var dx:Number = hotspot.x-character.spot.x;							var dy:Number = hotspot.y-character.spot.y;							var diffdist = dist-followdistance;							resetmove(character,null,new Point(character.spot.x+dx/dist*diffdist,character.spot.y+dy/dist*diffdist),diffdist<0);							handled = true;						}					}				}			}			return true;		}		////////////////////////////////////////		// world: Exposes the map object		public function set world(value:Object):void {			registry = {};			moveList = [];			thinkList = [];			mcCache = {};			map = value.map;			time = value.time;			if(value.background) {				background = value.background.image;				backgroundShift = value.background.shift;			}						pair = new Dictionary();			pair[null] = null;						populateLists();		}				public function get world():Object {			return {map:map,background:{image:background,shift:backgroundShift},time:time};		}	}}