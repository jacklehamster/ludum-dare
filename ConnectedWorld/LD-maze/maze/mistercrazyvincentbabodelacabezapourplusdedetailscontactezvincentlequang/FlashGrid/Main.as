package {	import flash.display.MovieClip;	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.events.MouseEvent;	import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.ui.Keyboard;	import flash.filters.GlowFilter;	import flash.external.ExternalInterface;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.geom.Matrix;	import flash.utils.Dictionary;	import flash.utils.setTimeout;	import flash.net.FileReference;	import Com;	import flash.display.Sprite;	import flash.display.Loader;	import flash.net.URLRequest;	import flash.display.LoaderInfo;	import flash.text.TextFieldAutoSize;	import flash.text.TextField;	import flash.text.TextLineMetrics;	import flash.text.StyleSheet;	import flash.events.TextEvent;	import com.adobe.crypto.MD5;	import flash.utils.Timer;	import flash.events.TimerEvent;	import flash.net.SharedObject;	import flash.net.URLLoader;	import flash.display.PNGEncoderOptions;	import flash.utils.ByteArray;	import flash.geom.Point;	import flash.system.ApplicationDomain;	import flash.utils.describeType;			/************************************	*	MAIN (GRID ENGINE DEMO)	*	*	© 24/11/2010 Vinh Le Quang	*	feel free to modify the code to fit your needs	*	*	This class is the document class of the flash.fla demo 	*	**********************************/	public class Main extends MovieClip{				static private const GOD:Boolean = true;				var world:World;		var grid:Grid;	//	our grid object		var mainCharacter;	//	main character		var focus;		//	active object		var shift:Point;	//	screen shift		var shiftGoal:Point;	//	destination screen shift		var screensize:Rectangle;	// screen size		var lasthilighted:MovieClip;	//	last hilighted object		var mdown:Point;	//	mouse down point		var dragged:Number;	//	dragged distance		var ghost:Object;	//	ghost object		var showxy:Boolean;	//	show xy floor				var currentzoom = 120;	//	actual zoom 120%		var zooming:Boolean = false;	//	zoom in progress		var preworld:Object = {};		var popup:Object;		var worldTimer:Timer = new Timer(1000);		public var invisCell:Number;		private var godhand:String;				static var bmpDico:Dictionary = new Dictionary();		// glow filters		const SELECTGLOW = new GlowFilter(0x0);	//	black		const HILIGHTGLOW = new GlowFilter(0xFF5500);	//	orange				////////////////////////////////////////		// MAIN CONSTRUCTOR initialize the game		function Main() {			if(stage)				init(loaderInfo.parameters);		}				public function destroy() {			activateEvents(false);		}				private function activateEvents(value:Boolean):void {/*			stage.addEventListener(MouseEvent.RIGHT_MOUSE_DOWN,				function(e:MouseEvent):void {					e.stopImmediatePropagation();					e.stopPropagation();					e.preventDefault();				},true,1);*/			stage.removeEventListener(MouseEvent.MOUSE_MOVE,mouseMove);			stage.removeEventListener(MouseEvent.MOUSE_DOWN,startDragging);			stage.removeEventListener(MouseEvent.MOUSE_UP,stopDragging);			stage.removeEventListener(Event.MOUSE_LEAVE,stopDragging);			stage.removeEventListener(MouseEvent.CLICK,onClick);			stage.removeEventListener(KeyboardEvent.KEY_DOWN,onKeydown);			stage.removeEventListener(KeyboardEvent.KEY_UP,onKeyup);			removeEventListener(Event.ENTER_FRAME,loop);			if(value) {				stage.addEventListener(MouseEvent.MOUSE_MOVE,mouseMove);				stage.addEventListener(MouseEvent.MOUSE_DOWN,startDragging);				stage.addEventListener(MouseEvent.MOUSE_UP,stopDragging);				stage.addEventListener(Event.MOUSE_LEAVE,stopDragging);				stage.addEventListener(MouseEvent.CLICK,onClick);				stage.addEventListener(KeyboardEvent.KEY_DOWN,onKeydown);				stage.addEventListener(KeyboardEvent.KEY_UP,onKeyup);				addEventListener(Event.ENTER_FRAME,loop);			}					}				public function init(params,data=null,davinci_loader=null) {			world = new  World(this);			grid = new Grid();			addChildAt(grid,0);						shift = new Point();			shiftGoal = new Point();			screensize = new Rectangle(0,0,stage.stageWidth/grid.scaleX,stage.stageHeight/grid.scaleY);						//	handle events			activateEvents(true);						//	javascript functions exposed for changing the world (remove this code before release)			/*			if(ExternalInterface.available) {				ExternalInterface.addCallback("getWorld",					function():String {						return JSON.stringify(grid.world,null,"\t");					});				ExternalInterface.addCallback("setWorld",					function(obj:String):void {						grid.world = JSON.parse(obj);					});			}			*/			currentzoom = 120;			zooming = false;			showxy = false;			zoombutton.addEventListener(MouseEvent.CLICK,onZoom);						xybutton.addEventListener(MouseEvent.CLICK,onShowXY);			worldbutton.addEventListener(MouseEvent.CLICK,onSaveWorld);			screenshotbutton.addEventListener(MouseEvent.CLICK,onSnapshot);			chatarea.visible = false;									icon.screen.addEventListener(MouseEvent.CLICK,				function(e) {					centerCharacter();					e.stopPropagation();				});			icon.screen.addEventListener(MouseEvent.MOUSE_MOVE,				function(e) {					var character:Object = grid.getById(mainCharacter);					hilight(grid.getClip(character));					e.stopPropagation();				});			icon.screen.buttonMode = true;						//icon.visible = false;						grid.checkDefinitions(ApplicationDomain.currentDomain,null);									initWorld();						worldTimer.addEventListener(TimerEvent.TIMER,saveWorldTimer);			worldTimer.start();					}				private function saveWorldTimer(e:TimerEvent):void {			var so:SharedObject = SharedObject.getLocal("flashgrid");			var world:Object = grid.world;			var exists:Object = {};			var designupdates:Array = so.data.designupdates || [];			var worldChanged:Boolean = false;						if(world.background) {				if(designupdates.indexOf("background")>=0) {					world.background = JSON.parse(so.data.background);				}				else {					so.setProperty("background",JSON.stringify(world.background));				}				exists.background = true;			}						for(var pos:String in world.map) {				var data:String = JSON.stringify(world.map[pos]);				if(so.data[pos]!=data) {					if(designupdates.indexOf(pos)>=0) {						world.map[pos] = JSON.parse(so.data[pos]);						worldChanged = true;					}					else {						so.setProperty(pos,data);					}				}				exists[pos] = true;			}			for(pos in so.data) {				if(!exists[pos]) {					so.setProperty(pos,null);				}			}			so.flush();			if(worldChanged) {				grid.world = world;			}		}		private function gotoDestination(e:CustomEvent):void {			var urlloader:URLLoader = new URLLoader();			var location:String = e.location;			urlloader.addEventListener(Event.COMPLETE,				function(e:Event):void {					var character:Object = grid.getById(mainCharacter);					var prelocation:Object = character.spot;										grid.world = JSON.parse(e.currentTarget.data);					character = grid.getById(mainCharacter);					var cell:Object = grid.getById(location);										var preScreen:Object = grid.grid2screen(prelocation.x,prelocation.y,shift);					var postScreen:Object = grid.grid2screen(cell.spot.x,cell.spot.y,shift);					shift.x += postScreen.x - preScreen.x;					shift.y += postScreen.y - preScreen.y;					grid.beam(character,cell.spot);					centerCharacter();					cell.startpoint = true;				});			urlloader.load(new URLRequest(e.map));		}				public function centerCharacter():void {			var character:Object = grid.getById(mainCharacter);			var screenPoint:Object= grid.grid2screen(character.spot.x,character.spot.y,shift);			shiftGoal.setTo(shift.x + screenPoint.x - stage.stageWidth/2,shift.y + screenPoint.y - stage.stageHeight/2);		}				function popInteractions(object:Object,interactions:Array) {			if(popup) {				grid.unregister(popup);				popup = null;			}			else {				popup = grid.add(object.spot,{className:"PopMessage",interactions:interactions,anchor:object.id,topMost:true});			}		}				function getInteractions(object:Object):Array {			var array:Array = object.interact is Array?object.interact.concat([]):[object.interact];			return array;		}				function onCellChange(e:CustomEvent):void {			var oldCell:Object = e.oldCell;			var newCell:Object = e.newCell;			var character:Object = e.character;						if(oldCell && oldCell.startpoint)				delete oldCell.startpoint;					}				////////////////////////////////////////		//	activateSubject: stardard click action on objects		function initWorld() {			world.init();									grid.addEventListener(CustomEvent.INTERACT,interactAction);			grid.addEventListener(CustomEvent.GOTO,gotoDestination);			grid.addEventListener(CustomEvent.CELLCHANGE,onCellChange);						//	as soon as the MovieClips of chair, wanda and zomba have been created, initialize them			grid.addEventListener("clipcreated",				function(e) {					var object = e.object;										if(e.clip is ChatBox) {						e.clip.tf.text = object.msg;					}					else if(e.clip is PopMessage) {						e.clip.tf.styleSheet = new StyleSheet();						e.clip.tf.styleSheet.setStyle("a:hover",{color:'#FF0000'});//						e.clip.tf.styleSheet.setStyle("a:link",{color:'#333333'});						e.clip.tf.autoSize = TextFieldAutoSize.CENTER;						e.clip.tf.text = "";						for(var i:int=0;i<object.interactions.length;i++) {							if(object.interactions[i].charAt(0)=='*') {								e.clip.tf.htmlText += "<font color='#000088'><a href='event:"+object.interactions[i]+"'>"+object.interactions[i].substr(1)+"</a></font><br>";							}							else {								e.clip.tf.htmlText += "<a href='event:"+object.interactions[i]+"'>"+object.interactions[i]+"</a><br>";							}						}						e.clip.tf.addEventListener(TextEvent.LINK,							function(e:TextEvent):void {								if(e.text.charAt(0)=="*") {									grid.dispatchEvent(CustomEvent.create("interact",{action:e.text,subject:grid.getById(object.anchor)}));								}								else {									var character:Object = grid.getById(mainCharacter);									command(character.id,character.itemlock&&character.itemlock!=object.anchor?"gocombo":e.text,object.anchor);								}								grid.unregister(popup);								popup = null;							});						e.clip.addEventListener(MouseEvent.CLICK,							function(e:MouseEvent):void {								e.stopPropagation();							});						e.clip.bg.height = e.clip.tf.height+5;						e.clip.bg.y = e.clip.tf.y+e.clip.tf.height/2;					}					if(object.interact) {						e.clip.addEventListener(MouseEvent.CLICK,							function(e) {								if(godhand) {									godhand = null;								}								else if(keys[Keyboard.NUMBER_4] && GOD) {									godhand = object.id;								}								else {									var character:Object = grid.getById(mainCharacter);									if(character.itemlock && character.itemlock!=object.id) {										command(character.id,"gocombo",object.id);									}									else {										var interactions:Array = getInteractions(object);										if(interactions.length==1) {											command(character.id,object.interact,object.id);										}										else {											popInteractions(object,interactions);										}									}								}								e.stopPropagation();							});						e.clip.addEventListener(MouseEvent.MOUSE_MOVE,							function(e) {								hilight(e.currentTarget);								e.stopPropagation();							});						e.clip.buttonMode = true;					}										if(object.character) {						e.clip.addEventListener(MouseEvent.MOUSE_MOVE,							function(e) {								hilight(e.currentTarget);								e.stopPropagation();							});						e.clip.addEventListener(MouseEvent.CLICK,clickCharacter);//						e.clip.addEventListener("arrived",characterArrived);//						e.clip.addEventListener("newdirection",newDirection);						e.clip.stop();						if(e.id==mainCharacter) {							e.clip.filters = [SELECTGLOW];						}						else {							e.clip.buttonMode = true;						}					}				});//			grid.startTime();		}				function notify(... more) {			trace(">>",more.join("|"));		}		////////////////////////////////////////		//	nicename: change format id to id(name)		function nicename(id) {			if(!id)				return null;			var obj = grid.getById(id);			return obj && obj.name?id + "(" + obj.name + ")":obj && obj.object?id + "(" + obj.object + ")":id;		}				////////////////////////////////////////		//	comboItem: combine two objects		function comboItem(item1,item2,char) {			if(!world.handle(item1,item2))				notify(nicename(char.id),"combo",nicename(item1.id),nicename(item2.id));		}		////////////////////////////////////////		//	activateSubject: stardard click action on objects		function useObject(obj,char) {			if(!world.handle(obj)) {				char.itemlock = null;				notify(nicename(char.id),"use",nicename(obj.id));			}		}				public function destroyObjects(...objects) {			var character:Object = grid.getById(mainCharacter);			grid.still(character);			for each(var obj:Object in objects) {				if(character.itemlock==obj.id)					character.itemlock = null;				character.inventory.splice(character.inventory.indexOf(obj),1);			}		}				private function verifyKey(objects:Array,...params):void {			params.sort();			var key:String = MD5.hash(params.join("$"));			trace("$$",params.join("$"),"=",key);			for each(var obj:Object in objects) {				if(obj.lock && obj.lock.key==key) {					for(var i:String in obj.lock.properties) {						obj[i] = obj.lock.properties[i];					}				}			}		}				////////////////////////////////////////		//	interactAction: happens when a character interacts with an object		function interactAction(e) {			var char = e.character;			var clip = char ? grid.getClip(char) : null;			if(e.subject)				verifyKey([e.subject],e.action,e.subject.object);			switch(e.action) {				case "use":					obj = e.subject;					useObject(obj,char);					break;				case "sit":					grid.still(char);					char.sitting = 1;//					if(clip) {//						clip.gotoAndStop("SWSit");//					}					char.itemlock = null;					break;				case "take":					//trace(JSON.encode(grid.world));					grid.still(char);					var obj = grid.retrieve(e.subject);					if(!char.inventory) {						char.inventory = [];					}					var item = grid.getClip(obj,true);					delete obj.spot;					obj.interact = "select";					char.inventory.push(obj);					Grid.popIn(item);					item.filters = [];					if(lasthilighted==item)						lasthilighted = null;					break;				case "drop":					grid.still(char);					obj = e.subject;					obj.interact = "take";					char.inventory.splice(char.inventory.indexOf(obj),1);					if(obj.type && ghost.type) {						obj.type=ghost.type;					}					grid.add(Grid.toPoint(char.spot),obj);					item = grid.getClip(obj,true);					Grid.popIn(item);					char.itemlock = null;					if(lasthilighted == item) {						lasthilighted = null;					}					item.filters = [];					break;				case "close":				case "open":					obj = e.subject;					obj.door = !obj.door;					obj.interact = obj.door?"close":"open";					item = grid.getClip(obj,true);					if(!obj.door && item.currentLabel!="opened")						item.gotoAndPlay("opening");					else if(obj.door && item.currentLabel!="closed")						item.gotoAndPlay("closing");					break;				case "select":					item = grid.getClip(e.subject,true);					ghost = {snap:e.subject.snap,object:e.subject.object,scale:e.subject.scale,type:e.subject.type,image:e.subject.image,ghost:1};					char.itemlock = char.itemlock==e.subject.id?null:e.subject.id;					break;				case "gocombo":				case "combo":					if(char.itemlock) {						var ilock = grid.getById(char.itemlock);						item = e.subject;						char.itemlock = null;						comboItem(ilock,item,char);						verifyKey([ilock,item],ilock.object,item.object);					}					break;				case "give":					if(char.itemlock) {						ilock = grid.getById(char.itemlock);						var subject = e.subject;						if(subject.accept&&subject.accept[ilock.id] || subject.team==char.team) {							if(!subject.inventory)								subject.inventory = [];							char.inventory.splice(char.inventory.indexOf(ilock),1);							subject.inventory.push(ilock);						}						char.itemlock = null;					}					break;				case "move":					//	idle now					break;				default:					world.handleInteraction(e.action,e.subject);					clip = grid.getClip(e.subject,true);					if(clip) {						clip.dispatchEvent(e);					}					break;			}			if(e.subject && e.subject.swf) {				loadSwf(extractSwf(e.subject));			}			else if(char) {				var cell:Object = grid.getCell(char.spot.x,char.spot.y);				//trace("??",JSON.stringify(cell));				if(cell && cell.swf) {					loadSwf(extractSwf(cell));				}			}		}				private function extractSwf(obj):String {			var swf:String;			if(obj.swf is Array) {				swf = obj.swf[0];				obj.swf.shift();				if(obj.swf.length==1)					obj.swf = obj.swf[1];			}			else {				swf = obj.swf;			}			return swf;		}				private function get cover():Boolean {			var sprite:Sprite = stage.getChildByName("cover") as Sprite;			return sprite && sprite.parent;		}				private function set cover(value:Boolean):void {			var sprite:Sprite = stage.getChildByName("cover") as Sprite;			if(!value && sprite) {				stage.removeChild(sprite);			}			else if(value && !sprite) {				hilight(null);				sprite = new Sprite();				sprite.graphics.beginFill(0,0);				sprite.graphics.drawRect(0,0,stage.stageWidth,stage.stageHeight);				sprite.graphics.endFill();				sprite.name = "cover";				stage.addChild(sprite);			}		}				private function loadSwf(swf:String):void {			if(swf) {				var character:Object = grid.getById(mainCharacter);				grid.still(character);				if(!grid.isVisible(character))					centerCharacter();				cover = true;				var loader:Loader = grid.loadSwf(swf,true,false);				loader.contentLoaderInfo.addEventListener(Event.COMPLETE,onLoaderComplete);				stage.addChild(loader);			}		}				private function onLoaderComplete(e:Event):void {			var loaderInfo:LoaderInfo = e.currentTarget as LoaderInfo;			var content:MovieClip = loaderInfo.content as MovieClip;			content.addEventListener(Event.CLOSE,removedLoader);		}				private function removedLoader(e:Event):void {			e.currentTarget.removeEventListener(e.type,arguments.callee);			var mc:MovieClip = e.currentTarget as MovieClip;			(mc.parent as Loader).unloadAndStop();			cover = false;		}				////////////////////////////////////////		//	iconCache: caches icons		static function iconCache(mc:MovieClip,imgwidth:int,imgheight:int,posx:int,posy:int,sx:Number,sy:Number):BitmapData {			var cache:Array = bmpDico[mc];			if(!cache) {				cache = bmpDico[mc] = [];			}			var bmpd:BitmapData = cache[mc.currentFrame];			if(!bmpd) {				bmpd = cache[mc.currentFrame] = new BitmapData(imgwidth,imgheight,true,0);				bmpd.unlock();				var f = mc.filters;				mc.filters = [];				bmpd.draw(mc,new Matrix(sx,0,0,sy,posx,posy),null,null,null,true);				mc.filters = f;			}			return bmpd;		}				private function adjustZoom():void {			if(currentzoom!=grid.zoom) {				shift.x -= stage.stageWidth/2 * grid.scaleX;				shift.y -= stage.stageHeight/2 * grid.scaleY;				grid.zoom = currentzoom;				shift.x += stage.stageWidth/2 * grid.scaleX;				shift.y += stage.stageHeight/2 * grid.scaleY;				screensize = new Rectangle(0,0,stage.stageWidth/grid.scaleX,stage.stageHeight/grid.scaleY);			}		}				private function adjustShift():void {			if(!shift.equals(shiftGoal)) {				if(Point.distance(shift,shiftGoal)<.1) {					shift.setTo(shiftGoal.x,shiftGoal.y);				}				else {					shift.x += (shiftGoal.x - shift.x)/3;					shift.y += (shiftGoal.y - shift.y)/3;				}			}		}		////////////////////////////////////////		//	loop: gets excecuted continuously		function loop(e) {			adjustZoom();			adjustShift();						var character:Object = grid.getById(mainCharacter);						//icon.visible = !grid.isVisible(character);						grid.loop(e);			var mspot = grid.screen2grid(				grid.mouseX,				grid.mouseY,shift);			//	show ghost object			if(ghost) {				if(character.itemlock) {					if(character && !character.goal) {						if(lasthilighted) {							ghost.hidden = true;						}						else {							var ipt = ghost.snap?{x:Math.round(mspot.x),y:Math.round(mspot.y)}:mspot;							var type = !ghost.type?null:grid.mouseX-grid.grid2screen(ipt.x,ipt.y,shift).x<0?"lwall":"rwall";							if(!type || grid.canBeam(ipt,type)) {								grid.beam(ghost,ipt,false,type);							}							ghost.hidden = false;						}					}				}				else {					grid.retrieve(ghost);					ghost = null;				}			}						if(godhand) {				var holdobj:Object = grid.getById(godhand);				ipt = holdobj.snap?{x:Math.round(mspot.x),y:Math.round(mspot.y)}:mspot;				type = !holdobj.type?null:grid.mouseX-grid.grid2screen(ipt.x,ipt.y,shift).x<0?"lwall":"rwall";				if(!type || grid.canBeam(ipt,type)) {					grid.beam(holdobj,ipt,false,type);				}				holdobj.hidden = false;			}						grid.display(shift,screensize,showxy,invisCell);						//	show character and inventory			var item;			var clip = grid.getClip(character);			while(icon.slots.numChildren) {				icon.slots.removeChildAt(0);			}			cursor.visible = !cover && (character && !character.goal && character.itemlock!=null||lasthilighted!=null);			if(cursor.visible) {				cursor.x = mouseX;				cursor.y = mouseY;				cursor.screen.visible = character && character.itemlock!=null;			}			if(clip) {									if(!icon.pic) {					icon.pic = new Bitmap();					icon.screen.addChild(icon.pic);				}				rect = clip.getRect(clip);				var sx = icon.screen.width/icon.screen.scaleX/rect.width;				var sy = icon.screen.height/icon.screen.scaleY/rect.height;				icon.pic.bitmapData = character.image&&!clip.skin?null:iconCache(clip,icon.screen.width,icon.screen.height,character.icon?character.icon[0]:-rect.x*sx,character.icon?character.icon[1]:-rect.y*sy,character.icon?character.icon[2]:sx,character.icon?character.icon[3]:sy);				if(character && character.inventory) {					var inventoryx = 5;					for(var i=0;i<character.inventory.length;i++) {						item = character.inventory[i];						clip = grid.getClip(item,true);/*						if(!clip.maxScale) {							clip.height = icon.screen.height;							clip.scaleX = clip.scaleY;							clip.maxScale = clip.scaleY;						}						if(clip.maxScale>icon.screen.height/clip.height) {													*/							clip.height = icon.screen.height;							clip.maxScale = clip.scaleX = clip.scaleY;						//}						var rect = clip.getRect(clip);						clip.x = inventoryx - rect.x * clip.scaleX;						clip.y = -rect.y * clip.scaleY;						icon.slots.addChild(clip);						inventoryx += clip.width+5;						clip.filters = character.itemlock==item.id?[SELECTGLOW]:[];					}				}				if(character.itemlock) {					if(!cursor.pic) {						cursor.alpha = .6;						cursor.mouseEnabled = cursor.mouseChildren = false;						cursor.pic = new Bitmap(null,"auto",true);						cursor.screen.addChild(cursor.pic);						cursor.screen.getChildAt(0).visible = false;					}					var obj = grid.getById(character.itemlock);					var mclock = grid.getClip(item,true);					rect = mclock.getRect(mclock);					sx = cursor.screen.width/cursor.screen.scaleX/rect.width;					sy = cursor.screen.height/cursor.screen.scaleY/rect.height;					cursor.pic.bitmapData = obj.image&&!obj.skin?null:iconCache(mclock,						cursor.screen.width/cursor.screen.scaleX,cursor.screen.height/cursor.screen.scaleY,obj.icon?obj.icon[0]:-rect.x*sx,obj.icon?obj.icon[1]:-rect.y*sy,obj.icon?obj.icon[2]:sx,obj.icon?obj.icon[3]:sy);					cursor.filters = character && !character.goal?[]:[SELECTGLOW];					if(character && !character.goal) {						if(lasthilighted) {							if(lasthilighted == mclock)								cursor.tf.text = "";							else {								var subjectobj = grid.getObj(lasthilighted);								if(subjectobj.object) {									cursor.tf.text = "use " + obj.object + " with " + subjectobj.object;								}								else if(subjectobj==character) {									cursor.tf.text = (obj.useName || "use") + " " + obj.object;								}								else if(subjectobj.name) {									cursor.tf.text = "give " + obj.object + " to " + subjectobj.name;								}							}						}						else {							cursor.tf.text = "drop " + obj.object;						}					}				}				else if(lasthilighted) {					item = grid.getObj(lasthilighted);					if(item)						cursor.tf.text = item.interactName || item.interact || '';				}				else {					cursor.tf.text = '';				}			}						// show hilighted object			/*			if(!icon2.pic) {				icon2.pic = new Bitmap();//new BitmapData(icon2.screen.width,icon2.screen.height));				icon2.screen.addChild(icon2.pic);			}						item = character.itemlock?grid.getById(character.itemlock):grid.getObj(lasthilighted);			var hiitem = grid.getClip(item);			if(item) {				rect = hiitem.getRect(hiitem);				var sx = icon.screen.width/rect.width;				var sy = icon.screen.height/rect.height;				iconCache(hiitem,icon2.screen.width,icon2.screen.height,item.icon?item.icon[0]:-rect.x*sx,item.icon?item.icon[1]:-rect.y*sy,item.icon?item.icon[2]:sx,item.icon?item.icon[3]:sy);				if(item && item.description) {									}			}*/						for(i in grid.world.map) {				if(preworld[i]!=JSON.stringify(grid.world.map[i])) {					preworld[i] = JSON.stringify(grid.world.map[i]);					//trace(preworld[i]);				}			}		}				////////////////////////////////////////		//	event when X,Y is clicked		function onShowXY(e) {			showxy = !showxy;			e.stopPropagation();		}				function onSaveWorld(e) {			var file:FileReference = new FileReference();			var text:String = JSON.stringify(grid.world,null,'\t');			file.save(text,"world.txt");			e.stopPropagation();		}				////////////////////////////////////////		//	event when ZOOM is clicked		function onZoom(e) {			targetZoom(currentzoom==120?60:currentzoom==60?170:120);			e.stopPropagation();		}				function targetZoom(zoomvalue) {			if(!zooming) {				zooming = true;				addEventListener(Event.ENTER_FRAME,					function(e) {						if(Math.abs(currentzoom-zoomvalue)>.1) {							currentzoom += (zoomvalue-currentzoom)/1.5;						}						else {							currentzoom =zoomvalue;							zooming = false;							e.currentTarget.removeEventListener(e.type,arguments.callee);						}					});			}		}				////////////////////////////////////////		//	event when a character is clicked		function clickCharacter(e) 		{			var char = grid.getObj(e.currentTarget);			clickCharObj(char);			e.stopPropagation();		}		////////////////////////////////////////		//	event when a character is clicked		function clickCharObj(char) 		{			var character:Object = grid.getById(mainCharacter);			if(character && character.itemlock) {				var obj = grid.getById(char.itemlock);				command(character.id,char==character?"use":"give",char==character?obj.id:char.id,char.spot);			}			else if(char && char!=character) {				var lastchar:Object = character;
				if(lastchar) {					grid.getClip(lastchar).filters = [];					grid.getClip(lastchar).buttonMode = true;					command(lastchar.id,"follow",char.id);					character = char;					mainCharacter = character.id;					grid.getClip(character).buttonMode = false;					grid.getClip(character).filters = [SELECTGLOW];					if(character.follow) {						command(character.id,"follow",null);					}
				}			}//			else {//				popInteractions(character,["inventory","status"]);//			}		}		////////////////////////////////////////		// command: A character gets issued a command to perform an action		public function command(characterID:String,activity:String,subjectID:String=null,spot:Object=null):Object {			if(spot) {				spot.x = Math.round(spot.x*100)/100;				spot.y = Math.round(spot.y*100)/100;			}			notify(nicename(characterID),activity,nicename(subjectID),Grid.toPoint(spot));			switch(activity) {				case "create":					return grid.add(new Point(spot.x,spot.y),JSON.parse(subjectID));					break;				case "say":					var character = grid.getById(characterID);					if(character.speech) {						var speech:Object = grid.getById(character.speech);						if(speech)							grid.unregister(speech);					}					var msg = grid.add(character.spot,{className:"ChatBox",msg:subjectID,anchor:characterID,topMost:true});					character.speech = msg.id;					grid.enlistThink(character);					return msg;					break;				case "follow":					grid.getById(characterID).follow = subjectID;					break;				case "setBackground":					grid.background = subjectID;					if(spot) {						grid.backgroundShift = spot;					}					break;				default:					return grid.action(characterID,activity,subjectID,spot);			}			return true;		}		////////////////////////////////////////		//	event when a character has arrived at destionation		function characterArrived(e) {			e.currentTarget.gotoAndStop(e.currentTarget.currentLabel);		}				////////////////////////////////////////		//	event when a character changes direction. In that case, change the label of the Movieclip		const DIRECTIONS = ['E','SE','S','SW','W','NW','N','NE'];		function newDirection(e) {			return;			var obj = grid.getObj(e.currentTarget);			var label:String = DIRECTIONS[(Math.round(8*(obj.direction+360)/360)+8)%8]			if(!label)				label = 'S';			e.currentTarget.gotoAndPlay(label);		}		var keys:Object = {};		function onKeydown(e:KeyboardEvent) {			keys[e.keyCode] = true;			setTimeout(				function():void {					if(e.keyCode==Keyboard.ENTER && (stage.focus!=chatarea.chatbox||!chatarea.visible)) {						chatarea.chatbox.text = "";						chatarea.visible = true;						stage.focus = chatarea.chatbox;						updateSidebar();						e.preventDefault();						e.stopImmediatePropagation();						e.stopPropagation();					}					else if(e.keyCode==Keyboard.ENTER) {						if(chatarea.chatbox.text && chatarea.chatbox.text.length) {							var character = grid.getById(mainCharacter);							chatarea.chatbox.text = chatarea.chatbox.text.substr(0,chatarea.chatbox.text.length-1);							command(character.id,"say",chatarea.chatbox.text);							interpret(chatarea.chatbox.text);						}						chatarea.chatbox.text = "";						chatarea.visible = false;					}				},0);		}				function updateSidebar():void {//			trace(chatarea.sidebar.);			var y:int=0, defs:Array = [];			for(var i:String in grid.definitions) {				defs.push(i);			}			defs.sort();						if(!chatarea.sidebar.inited) {				chatarea.sidebar.inited = true;				chatarea.sidebar.shift = 0;				chatarea.sidebar.addEventListener(MouseEvent.MOUSE_WHEEL,					function(e:MouseEvent):void {						chatarea.sidebar.shift += e.delta;						updateSidebar();					});			}						defs = defs.concat(defs.splice(0,(chatarea.sidebar.shift+defs.length)%defs.length));						for each(var def:String in defs) {//				trace(i,grid.definitions[i]);				var sprite:Sprite = chatarea.sidebar.getChildByName(def);				if(!sprite) {					sprite = createSidebarSprite(def,grid.definitions[def]);//					trace(i,JSON.stringify(grid.definitions[i]));				}				if(sprite) {					sprite.y = y;					y += sprite.height;					chatarea.sidebar.addChild(sprite);				}			}		}				private function createSidebarSprite(def:String,definition:Object):Sprite {			if(!definition.object)				return null;			if(grid.definitions[def].definition==Main)				return null;			if(def.indexOf("::")>=0)				return null;			var desc:XML = describeType(grid.definitions[def].definition);			if(desc.factory.extendsClass.@type.toString().indexOf('flash.display::Sprite')<0)				return null;			var o:Object = new grid.definitions[def].definition;			if(!(o is Sprite))				return null;			var sprite:Sprite = new grid.definitions[def].definition;			if(sprite is MovieClip)				(sprite as MovieClip).stop();			sprite.name = def;			sprite.scaleX = sprite.scaleY =				Math.min(60/sprite.width,60/sprite.height);			sprite.addEventListener(MouseEvent.CLICK,				function(e:MouseEvent):void {					var params:Object = {className:def, className:def};					params.object= definition.object;					if(definition.file)						params.file = definition.file;					if(definition.hotspot)						params.hotspot = definition.hotpsot;//					params.interact = "take";//					params.id = grid.createID();//					grid.register(params);//					grid.getClip(params,true);					var character:Object = grid.getById(mainCharacter);					var obj:Object = command(null,"create",JSON.stringify(params),character.spot);					godhand = obj.id;					//command(character.id,"take",obj.id,character.spot);					//character.itemlock = params.id;//					if(!character.inventory) {//						character.inventory = [];//					}//					character.inventory.push(params);					e.stopPropagation();					e.preventDefault();				});			return sprite;		}				function onKeyup(e:KeyboardEvent) {			delete keys[e.keyCode];		}				function interpret(message:String):void {			var tokens:Array = message.split(" ");			switch(tokens[0]) {				case "cleanworld":					cleanWorld();					break;				case "squareworld":					standardWorld("square",tokens[1]?parseInt(tokens[1]):0);					break;				case "diamondworld":					standardWorld("diamond",tokens[1]?parseInt(tokens[1]):0);					break;				case "circleworld":					standardWorld("circle",tokens[1]?parseInt(tokens[1]):0);					break;				case "center":					centerCharacter();					break;				case "setbg":					command(null,"setBackground",tokens[1]);					break;				case "inviscell":					if(tokens[1]) {						invisCell = parseFloat(tokens[1]);					}					else {						invisCell = invisCell?0:1;					}					break;				case "shiftbg":					if(!grid.getChildByName("background"))						return;					activateEvents(false);					grid.alpha = .3;					grid.getChildByName("background").alpha = 1/grid.alpha;					stage.addEventListener(MouseEvent.MOUSE_DOWN,						function(e:MouseEvent):void {							e.currentTarget.removeEventListener(e.type,arguments.callee);							e.stopPropagation();							var point:Point = new Point(e.stageX,e.stageY);							stage.addEventListener(MouseEvent.MOUSE_MOVE,								function(e:MouseEvent):void {									e.stopPropagation();									if(e.buttonDown) {										grid.backgroundShift = new Point(e.stageX,e.stageY).subtract(point);										grid.display(shift,screensize,false,0,false);									}									else {										grid.alpha = 1;										grid.getChildByName("background").alpha = 1;										activateEvents(true);										e.currentTarget.removeEventListener(e.type,arguments.callee);									}								},false,1);						},false,1);					break;				case "load":					grid.loadSwf(tokens[1],true,true)					break;				default:					trace(tokens);					break;			}		}				function cleanWorld():void {			var character:Object = grid.getById(mainCharacter);			grid.removeObjects(null,character);			grid.removeObjects("floor");			grid.removeObjects("lwall");			grid.removeObjects("rwall");		}				function relocateMainCharacter(x:Number,y:Number):void {			var character = grid.getById(mainCharacter);			var preScreen:Object = grid.grid2screen(character.spot.x,character.spot.y,shift);			var postScreen:Object = grid.grid2screen(x,y,shift);			shift.x += postScreen.x - preScreen.x;			shift.y += postScreen.y - preScreen.y;			grid.beam(character,{x:x,y:y});			grid.still(character);			centerCharacter();		}				function standardWorld(shape:String,size:int):void {			var x:int,y:int;			if(!size)				size = 8;			switch(shape) {				case "diamond":					cleanWorld();					for(y=0;y<size;y++) {						for(x=0;x<size;x++) {							if(Math.abs(size/2-x)+Math.abs(size/2-y)<Math.ceil(size/2)) {								command(null,"create",'{"type":"floor","image":"metaltile.png"}',{x:x,y:y});								if(y==0) {									command(null,"create",'{"type":"lwall","image":"glasswall.png"}',{x:x,y:y});								}								if(x==size-1) {									command(null,"create",'{"type":"rwall","image":"glasswall.png"}',{x:x,y:y});								}							}						}					}					relocateMainCharacter(size/2,size/2);					break;				case "circle":					cleanWorld();					for(y=0;y<size;y++) {						for(x=0;x<size;x++) {							if((size/2-x)*(size/2-x)+(size/2-y)*(size/2-y)<(size/2)*(size/2)) {								command(null,"create",'{"type":"floor","image":"metaltile.png"}',{x:x,y:y});								if(y==0) {									command(null,"create",'{"type":"lwall","image":"glasswall.png"}',{x:x,y:y});								}								if(x==size-1) {									command(null,"create",'{"type":"rwall","image":"glasswall.png"}',{x:x,y:y});								}							}						}					}					relocateMainCharacter(size/2,size/2);					break;				case "square":					cleanWorld();					for(y=0;y<size;y++) {						for(x=0;x<size;x++) {							command(null,"create",'{"type":"floor","image":"metaltile.png"}',{x:x,y:y});							if(y==0) {								command(null,"create",'{"type":"lwall","image":"glasswall.png"}',{x:x,y:y});							}							if(x==size-1) {								command(null,"create",'{"type":"rwall","image":"glasswall.png"}',{x:x,y:y});							}						}					}					relocateMainCharacter(size/2,size/2);					break;			}		}		////////////////////////////////////////		//	event when the screen is clicked. Either walk or drag		function onClick(e:MouseEvent) {			if(dragged) {			}			else if(popup) {				grid.unregister(popup);				popup = null;			}			else if(godhand) {				godhand = null;			}			else if(keys[Keyboard.NUMBER_1] && GOD) {				mspot = grid.screen2grid(grid.mouseX,grid.mouseY,shift);				var cell = grid.find(mspot,"floor");				if(!cell) {					command(null,"create",'{"type":"floor","image":"woodtile.png"}',{x:Math.round(mspot.x),y:Math.round(mspot.y)});				}				else {					grid.unregister(cell);				}			}			else if(keys[Keyboard.NUMBER_2] && GOD) {				mspot = grid.screen2grid(grid.mouseX,grid.mouseY,shift);				cell = grid.find(mspot,"lwall");				if(!cell) {					command(null,"create",'{"type":"lwall","image":"glasswall.png"}',{x:Math.round(mspot.x),y:Math.round(mspot.y)});				}				else {					grid.unregister(cell);				}			}			else if(keys[Keyboard.NUMBER_3] && GOD) {				mspot = grid.screen2grid(grid.mouseX,grid.mouseY,shift);				cell = grid.find(mspot,"rwall");				if(!cell) {					command(null,"create",'{"type":"rwall","image":"glasswall.png"}',{x:Math.round(mspot.x),y:Math.round(mspot.y)});				}				else {					grid.unregister(cell);				}			}			else if(!cover) {				var character = grid.getById(mainCharacter);				var mspot = grid.screen2grid(grid.mouseX,grid.mouseY,shift);				var clip = grid.getClip(character);				var interobj = grid.find(mspot,{interact:null});								if(interobj) {					command(character.id,character.itemlock?"combo":interobj.interact,interobj.id);				}				else if(character && character.itemlock) {					if(character.goal || character.thought) {						character.goal = null;						character.thought = null;						character.itemlock = null;						command(character.id,"move",null,mspot);					}					else {						command(character.id,"drop",character.itemlock,{x:mspot.x,y:mspot.y});					}				}				else if(character && (character.goal || character.thought)) {						character.goal = null;						character.thought = null;						command(character.id,"move",null,mspot);				} else if(character) {					command(character.id,"move",null,mspot);				}			}					}		////////////////////////////////////////		//	event the screen is dragged		function startDragging(e) {			if(!cover) {				dragged = 0;				mdown = new Point(mouseX,mouseY);			}		}		////////////////////////////////////////		//	event the mouse is released or exists the screen		function stopDragging(e) {			mdown = null;			e.stopPropagation();		}				////////////////////////////////////////		//	event the mouse moves. Used to detect hilights and calculate screen drag		function mouseMove(e) {			if(mdown) {				var dist:Number = Point.distance(mdown,new Point(mouseX,mouseY));				if(dist>3) {					dragged += dist;					shiftGoal.x += (mdown.x-mouseX)*1.5;					shiftGoal.y += (mdown.y-mouseY)*1.5;					mdown.x = mouseX;					mdown.y = mouseY;				}			}			else if(!cover) {				var mspot = grid.screen2grid(grid.mouseX,grid.mouseY,shift);				var obj = grid.find(mspot,{interact:null});				var clip = !obj||obj.character?null:grid.getClip(obj);				hilight(clip);				/*				if(obj) {					chatarea.infospace.text = JSON.stringify(obj,null,'  ');				}				else {					obj = grid.find(mspot,"floor");					chatarea.infospace.text = JSON.stringify(obj,null,'  ');				}*/			}			e.updateAfterEvent();		}				////////////////////////////////////////		//	add a orange glow around the mouse overed movie clip		function hilight(clip:MovieClip) {			var character = grid.getById(mainCharacter);			var itemlock = character && character.itemlock?grid.getClip(grid.getById(character.itemlock)):null			if(lasthilighted && lasthilighted != clip && itemlock!=lasthilighted) {				lasthilighted.filters = lasthilighted==grid.getClip(character) ? [SELECTGLOW] : [];			}			if(clip && (!itemlock||itemlock!=clip)) {				clip.filters = [HILIGHTGLOW];			}			lasthilighted = clip;		}				private function reduceRect(bitmapData:BitmapData):Rectangle {			var bounds : Rectangle = bitmapData.getColorBoundsRect(0xFFFFFFFF, 0x000000, false);			return bounds;		}				function onSnapshot(e:MouseEvent):void {			var rect:Rectangle = grid.getRect(grid);			var bitmapData:BitmapData = new BitmapData(rect.width,rect.height,true,0);			grid.display(shift,screensize,false,0,true);			bitmapData.draw(grid,new Matrix(1,0,0,1,-rect.left,-rect.top));			addChild(new Bitmap(bitmapData));			var bytes:ByteArray = bitmapData.encode(reduceRect(bitmapData),new PNGEncoderOptions());			var file:FileReference = new FileReference();			file.save(bytes,"map.png");			bitmapData.dispose();			e.stopPropagation();		}	}}